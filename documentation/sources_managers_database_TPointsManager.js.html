<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>sources/managers/database/TPointsManager.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="MeshManager.html">MeshManager</a></li><li><a href="TApplication.html">TApplication</a><ul class='methods'><li data-type='method'><a href="TApplication.html#.removeDiacritics">removeDiacritics</a></li><li data-type='method'><a href="TApplication.html#askUserForPosition">askUserForPosition</a></li><li data-type='method'><a href="TApplication.html#changeMaterialSide">changeMaterialSide</a></li><li data-type='method'><a href="TApplication.html#endMeasure">endMeasure</a></li><li data-type='method'><a href="TApplication.html#initRequest">initRequest</a></li><li data-type='method'><a href="TApplication.html#insertTreeViewItem">insertTreeViewItem</a></li><li data-type='method'><a href="TApplication.html#loadObjectFromURL">loadObjectFromURL</a></li><li data-type='method'><a href="TApplication.html#popupImageShotModal">popupImageShotModal</a></li><li data-type='method'><a href="TApplication.html#popupImportFilesModal">popupImportFilesModal</a></li><li data-type='method'><a href="TApplication.html#popupSelectedObjectModal">popupSelectedObjectModal</a></li><li data-type='method'><a href="TApplication.html#removeMeasure">removeMeasure</a></li><li data-type='method'><a href="TApplication.html#removeTemporaryMeasure">removeTemporaryMeasure</a></li><li data-type='method'><a href="TApplication.html#resetDataPanel">resetDataPanel</a></li><li data-type='method'><a href="TApplication.html#setCameraMode">setCameraMode</a></li><li data-type='method'><a href="TApplication.html#setLayerGroupVisibility">setLayerGroupVisibility</a></li><li data-type='method'><a href="TApplication.html#setMapViewer">setMapViewer</a></li><li data-type='method'><a href="TApplication.html#setRendersEffect">setRendersEffect</a></li><li data-type='method'><a href="TApplication.html#startMeasure">startMeasure</a></li><li data-type='method'><a href="TApplication.html#updateAvatar">updateAvatar</a></li><li data-type='method'><a href="TApplication.html#updateDataPanel">updateDataPanel</a></li><li data-type='method'><a href="TApplication.html#updateImageShot">updateImageShot</a></li><li data-type='method'><a href="TApplication.html#updateMapViewer">updateMapViewer</a></li><li data-type='method'><a href="TApplication.html#updateMapViewerOrientation">updateMapViewerOrientation</a></li><li data-type='method'><a href="TApplication.html#updateMapViewerPosition">updateMapViewerPosition</a></li><li data-type='method'><a href="TApplication.html#updateMeasure">updateMeasure</a></li><li data-type='method'><a href="TApplication.html#updateMeshResolution">updateMeshResolution</a></li><li data-type='method'><a href="TApplication.html#updatePointCloudDensity">updatePointCloudDensity</a></li><li data-type='method'><a href="TApplication.html#updateTemporaryMeasure">updateTemporaryMeasure</a></li><li data-type='method'><a href="TApplication.html#updateViewportSizes">updateViewportSizes</a></li></ul></li><li><a href="TCache.html">TCache</a><ul class='methods'><li data-type='method'><a href="TCache.html#add">add</a></li><li data-type='method'><a href="TCache.html#clear">clear</a></li><li data-type='method'><a href="TCache.html#get">get</a></li><li data-type='method'><a href="TCache.html#remove">remove</a></li></ul></li><li><a href="TDataBaseManager.html">TDataBaseManager</a><ul class='methods'><li data-type='method'><a href="TDataBaseManager.html#._statusOk">_statusOk</a></li><li data-type='method'><a href="TDataBaseManager.html#.requestServer">requestServer</a></li><li data-type='method'><a href="TDataBaseManager.html#_create">_create</a></li><li data-type='method'><a href="TDataBaseManager.html#_deleteOne">_deleteOne</a></li><li data-type='method'><a href="TDataBaseManager.html#_deleteSome">_deleteSome</a></li><li data-type='method'><a href="TDataBaseManager.html#_onArrayBuffer">_onArrayBuffer</a></li><li data-type='method'><a href="TDataBaseManager.html#_onBlob">_onBlob</a></li><li data-type='method'><a href="TDataBaseManager.html#_onError">_onError</a></li><li data-type='method'><a href="TDataBaseManager.html#_onJson">_onJson</a></li><li data-type='method'><a href="TDataBaseManager.html#_onLoad">_onLoad</a></li><li data-type='method'><a href="TDataBaseManager.html#_onProgress">_onProgress</a></li><li data-type='method'><a href="TDataBaseManager.html#_onText">_onText</a></li><li data-type='method'><a href="TDataBaseManager.html#_readOne">_readOne</a></li><li data-type='method'><a href="TDataBaseManager.html#_readSome">_readSome</a></li><li data-type='method'><a href="TDataBaseManager.html#_updateOne">_updateOne</a></li><li data-type='method'><a href="TDataBaseManager.html#_updateSome">_updateSome</a></li><li data-type='method'><a href="TDataBaseManager.html#create">create</a></li><li data-type='method'><a href="TDataBaseManager.html#delete">delete</a></li><li data-type='method'><a href="TDataBaseManager.html#read">read</a></li><li data-type='method'><a href="TDataBaseManager.html#update">update</a></li></ul></li><li><a href="TErrorManager.html">TErrorManager</a></li><li><a href="TFactory.html">TFactory</a></li><li><a href="TGeometriesManager.html">TGeometriesManager</a><ul class='methods'><li data-type='method'><a href="TGeometriesManager.html#convertJsonToGeometry">convertJsonToGeometry</a></li></ul></li><li><a href="TMaterialsManager.html">TMaterialsManager</a></li><li><a href="TObjectsManager.html">TObjectsManager</a></li><li><a href="TOrbitControlsHelper.html">TOrbitControlsHelper</a></li><li><a href="TOrchestrator.html">TOrchestrator</a><ul class='methods'><li data-type='method'><a href="TOrchestrator.html#processQueue">processQueue</a></li><li data-type='method'><a href="TOrchestrator.html#queue">queue</a></li></ul></li><li><a href="TPointsManager.html">TPointsManager</a></li><li><a href="TProgressManager.html">TProgressManager</a></li><li><a href="TScenesManager.html">TScenesManager</a></li><li><a href="TUniversalLoader.html">TUniversalLoader</a></li><li><a href="TViewport.html">TViewport</a></li></ul><h3>Modules</h3><ul><li><a href="module-config_babelConfiguration.html">config/babelConfiguration</a><ul class='methods'><li data-type='method'><a href="module-config_babelConfiguration.html#~CreateBabelConfiguration">CreateBabelConfiguration</a></li></ul></li><li><a href="module-config_eslintConfiguration.html">config/eslintConfiguration</a><ul class='methods'><li data-type='method'><a href="module-config_eslintConfiguration.html#~CreateEslintConfiguration">CreateEslintConfiguration</a></li></ul></li><li><a href="module-config_jsdocConfiguration.html">config/jsdocConfiguration</a><ul class='methods'><li data-type='method'><a href="module-config_jsdocConfiguration.html#~CreateJsdocConfiguration">CreateJsdocConfiguration</a></li></ul></li><li><a href="module-config_karmaBenchConfiguration.html">config/karmaBenchConfiguration</a><ul class='methods'><li data-type='method'><a href="module-config_karmaBenchConfiguration.html#~CreateKarmaBenchmarkConfiguration">CreateKarmaBenchmarkConfiguration</a></li></ul></li><li><a href="module-config_karmaUnitConfiguration.html">config/karmaUnitConfiguration</a><ul class='methods'><li data-type='method'><a href="module-config_karmaUnitConfiguration.html#~CreateKarmaUnitTestingConfiguration">CreateKarmaUnitTestingConfiguration</a></li></ul></li><li><a href="module-config_rollupConfiguration.html">config/rollupConfiguration</a><ul class='methods'><li data-type='method'><a href="module-config_rollupConfiguration.html#~CreateRollupConfiguration">CreateRollupConfiguration</a></li></ul></li><li><a href="module-gulpfile.html">gulpfile</a><ul class='methods'><li data-type='method'><a href="module-gulpfile.html#~gulp_convert-anaglyph-effect-to-es6-module">gulp _convert-anaglyph-effect-to-es6-module</a></li><li data-type='method'><a href="module-gulpfile.html#~gulp_convert-detector-to-es6-module">gulp _convert-detector-to-es6-module</a></li><li data-type='method'><a href="module-gulpfile.html#~gulp_convert-orbit-controls-to-es6-module">gulp _convert-orbit-controls-to-es6-module</a></li><li data-type='method'><a href="module-gulpfile.html#~gulp_convert-stereo-effect-to-es6-module">gulp _convert-stereo-effect-to-es6-module</a></li><li data-type='method'><a href="module-gulpfile.html#~gulp_extendThree">gulp _extendThree</a></li><li data-type='method'><a href="module-gulpfile.html#~npmrunbench">npm run bench</a></li><li data-type='method'><a href="module-gulpfile.html#~npmrunbuild">npm run build</a></li><li data-type='method'><a href="module-gulpfile.html#~npmrunclean">npm run clean</a></li><li data-type='method'><a href="module-gulpfile.html#~npmrundoc">npm run doc</a></li><li data-type='method'><a href="module-gulpfile.html#~npmrunlint">npm run lint</a></li><li data-type='method'><a href="module-gulpfile.html#~npmrunrelease">npm run release</a></li><li data-type='method'><a href="module-gulpfile.html#~npmruntest">npm run test</a></li><li data-type='method'><a href="module-gulpfile.html#~npmrununit">npm run unit</a></li><li data-type='method'><a href="module-gulpfile.html#~npmrunhelpdefault">npm run help </a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#addPointsFromBuffer">addPointsFromBuffer</a></li><li><a href="global.html#endianness">endianness</a></li><li><a href="global.html#getPointClouds">getPointClouds</a></li><li><a href="global.html#getSamplingForDistanceToCamera">getSamplingForDistanceToCamera</a></li><li><a href="global.html#HttpStatusCode">HttpStatusCode</a></li><li><a href="global.html#HttpVerb">HttpVerb</a></li><li><a href="global.html#ResponseType">ResponseType</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">sources/managers/database/TPointsManager.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @class TPointsManager
 * @classdesc The TPointsManager allow to get and dump, in a webglviewport, cloud data retrieve from Itee server
 * @example Todo
 *
 */

/* eslint-env browser */
/* eslint no-unused-vars: warn */
/* global $ */

import { BufferGeometry } from '../../../node_modules/three/src/core/BufferGeometry'
import { BufferAttribute } from '../../../node_modules/three/src/core/BufferAttribute'
import { PointsMaterial } from '../../../node_modules/three/src/materials/PointsMaterial'
import { Points } from '../../../node_modules/three/src/objects/Points'
import { Group } from '../../../node_modules/three/src/objects/Group'

/**
 *
 * @param viewport
 * @constructor
 */

function TPointsManager ( viewport ) {

    if( ! viewport ) { throw new Error( 'Unable to create point cloud manager for null or undefined viewport !' ) }

    this._pointCloudsDataMap = new Map()
    this._cameraDistanceMax  = 10.0
    this._cameraDistanceMin  = 1.0
    this._samplingMax        = 100
    this._samplingMin        = 0.0
    this._viewport           = viewport
    this._globalOffset       = {
        x: 0,
        y: 0,
        z: 0
    }
    this._pointCloudGroup = new Group()
    this._pointCloudGroup.name = 'PointClouds'

    this._viewport.scene.add( this._pointCloudGroup )

}

Object.assign( TPointsManager, {} );

Object.assign( TPointsManager.prototype, {

    setGlobalOffset: function ( globalOffset ) {

        this._globalOffset = globalOffset

    },

    setMinimumSamplingLimit: function ( sampling ) {

        this._samplingMin = sampling

    },

    setMaximumSamplingLimit: function ( sampling ) {

        this._samplingMax = sampling

    },

    /**
     *
     */
    getPointClouds: function ( onSuccess ) {

        var self = this

        $.ajax( {
            type:     'GET',
            url:      '/worldcells/',
            dataType: 'json',
            cache:    false,
            success:  function ( worldCells ) {

                if ( !worldCells || worldCells.length === 0 ) {
                    console.warn( 'Unable to find world cells !' )
                    return
                }

                // Create the main point cloud data tree
                self.createPointCloudDataMap( worldCells )

                onSuccess()
                
            },
            error:    function ( jqXHR, textStatus, errorThrown ) {
                console.log( 'ERRORS: ' + textStatus )
            }
        } )

    },

    createPointCloudDataMap: function ( worldCells ) {

        var cell = undefined
        for ( var cellIndex = 0, numberOfCells = worldCells.length ; cellIndex &lt; numberOfCells ; cellIndex++ ) {

            cell = worldCells[ cellIndex ]

            var pointClouds  = cell.cubeDataPoint
            var pointCloud   = undefined
            var pointCloudId = undefined
            for ( var pointCloudIndex = 0, numberOfPointClouds = pointClouds.length ; pointCloudIndex &lt; numberOfPointClouds ; pointCloudIndex++ ) {

                pointCloud   = pointClouds[ pointCloudIndex ]
                pointCloudId = pointCloud.id

                this._pointCloudsDataMap.set( pointCloudId, {
                    id:               pointCloudId,
                    parentCellId:     cell.id,
                    coordinates:      {
                        x: pointCloud.coordinates.x + cell.lambertCoordinates.x,
                        y: pointCloud.coordinates.y + cell.lambertCoordinates.y,
                        z: pointCloud.coordinates.z + cell.lambertCoordinates.z
                    },
                    sampling:         0.0,
                    previousSampling: 0.0,
                    needIncrease:     false, // Only if sampling grows
                    needDecrease:     false // Only if sampling decrease
                } )

            }

        }

    },

    updatePointClouds: function ( cameraWorldPosition ) {

        var cloudIdsToIncreaseData = []
        var cloudIdsToDecreaseData  = []

        this._pointCloudsDataMap.forEach(function( pointCloud ) {

            this.updatePointCloudSampling( pointCloud, cameraWorldPosition )

            if( pointCloud.needIncrease ) {

                cloudIdsToIncreaseData.push( pointCloud.id )

            } else if ( pointCloud.needDecrease ) {

                cloudIdsToDecreaseData.push( pointCloud.id )

            } else {

                // nothings

            }

        }.bind(this))

        this.increasePointCloudData( cloudIdsToIncreaseData )
        this.decreasePointCloudData( cloudIdsToDecreaseData )

    },

    updatePointCloudSampling: function ( pointCloud, cameraWorldPosition ) {

        var pointCloudWorldCoordinates = {
            x: pointCloud.coordinates.x - this._globalOffset.x,
            y: pointCloud.coordinates.z - this._globalOffset.z,
            z: -(pointCloud.coordinates.y - this._globalOffset.y)
        }

        // TODO: Could be only power of two instead of a Sqrt !!!
        var distanceToCamera = Math.sqrt(
            Math.pow( (pointCloudWorldCoordinates.x - cameraWorldPosition.x), 2 ) +
            Math.pow( (pointCloudWorldCoordinates.y - cameraWorldPosition.y), 2 ) +
            Math.pow( (pointCloudWorldCoordinates.z - cameraWorldPosition.z), 2 )
        )

        var sampling = this.getSamplingForDistanceToCamera( distanceToCamera )

        if( sampling > pointCloud.sampling ) {

            pointCloud.needIncrease = true
            pointCloud.needDecrease = false

        } else if( sampling &lt; pointCloud.sampling ) {

            pointCloud.needIncrease = false
            pointCloud.needDecrease = true

        } else {

            pointCloud.needIncrease = false
            pointCloud.needDecrease = false

        }

        pointCloud.previousSampling = pointCloud.sampling
        pointCloud.sampling         = sampling

    },

    /**
     *
     * @param distanceToCamera
     * @returns {number}
     */
    getSamplingForDistanceToCamera: function ( distanceToCamera ) {

        // If camera is out limits set default value
        if ( distanceToCamera &lt; this._cameraDistanceMin ) { return this._samplingMax }
        if ( distanceToCamera > this._cameraDistanceMax ) { return this._samplingMin }

//        var result = (-10 * distanceToCamera) + 100
        var result = (100 / Math.pow( distanceToCamera, 2 ))

        // Round at 2 digit
        var sampling = Math.round( result * 100 ) / 100

        // Limits sampling in case where function return value outer limits
        if ( sampling &lt; this._samplingMin ) { sampling = this._samplingMin }
        if ( sampling > this._samplingMax ) { sampling = this._samplingMax }

        return sampling

    },

    increasePointCloudData: function ( cloudIds ) {

        if( cloudIds.length === 0 ) { return }
        console.log( 'numberOfBuffers to increase: ' + cloudIds.length )


        var self = this

        var url           = '/pointclouds/'
        var samplingTable = this.createSamplingTable( cloudIds )
        var jsonData      = strMapToJson( samplingTable )

        //        this.requestDataBuffer( url, samplingTable, callback )

        var request          = new XMLHttpRequest()
        request.responseType = 'arraybuffer'
        request.onload       = onLoad

        request.open( 'POST', url, true )
        request.setRequestHeader( 'Content-Type', 'application/json' )
        request.send( jsonData )

        function onLoad ( data ) {

            var arrayBuffer = data.target.response
            if ( arrayBuffer.byteLength &lt;= 4 ) { return }

            var buffer          = new DataView( arrayBuffer )
            var numberOfBuffers = buffer.getUint32( 0 )
            if ( numberOfBuffers === 0 ) { return }

//            console.log( 'numberOfBuffers to extract: ' + numberOfBuffers )

            const NUMBER_OF_BUFFER_VALUE_BYTES_LENGTH = 4 // UInt32
            var SIZES_OF_BUFFER_ARRAY_BYTES_LENGTH    = numberOfBuffers * 4 // UInt32
            var dataOffset                            = NUMBER_OF_BUFFER_VALUE_BYTES_LENGTH + SIZES_OF_BUFFER_ARRAY_BYTES_LENGTH

            var bufferLength = 0
            var byteArray    = undefined
            for ( var bufferIndex = 4 ; bufferIndex &lt;= SIZES_OF_BUFFER_ARRAY_BYTES_LENGTH ; bufferIndex += 4 ) {

                bufferLength = buffer.getUint32( bufferIndex )
                byteArray    = new Uint8Array( arrayBuffer, dataOffset, bufferLength )

                self.addPointsFromBuffer( byteArray )

                dataOffset += bufferLength

            }

        }

        function strMapToJson ( strMap ) {

            return JSON.stringify( strMapToObj( strMap ) )

        }

        function strMapToObj ( strMap ) {

            var obj = Object.create( null )

            strMap.forEach( function ( value, key ) {

                obj[ key ] = value

            } )

            return obj

        }

    },

    decreasePointCloudData: function ( cloudIds ) {

        if( cloudIds.length === 0 ) { return }
        console.log( 'numberOfBuffers to decrease: ' + cloudIds.length )

        var self = this

        console.log("Number of children (base): " + self._pointCloudGroup.children.length);
        cloudIds.forEach( function ( cloudId ) {

            var pointCloud3D = self._pointCloudGroup.getObjectByName( cloudId )
            if( ! pointCloud3D ) { return }

            // Get sampling delta to apply
            var pointCloud = self._pointCloudsDataMap.get( cloudId )
            var sampling = pointCloud.sampling
            var previousSampling = pointCloud.previousSampling

            var positionBufferAttribute = pointCloud3D.geometry.getAttribute( 'position' )
            var colorBufferAttribute = pointCloud3D.geometry.getAttribute( 'color' )

            // Apply delta sampling to 3d object geometry
            var numberOfPoints = positionBufferAttribute.count
            if( numberOfPoints === 0 ) { return } // If already empty return

            var numberOfRestPoints = Math.round( ( numberOfPoints * sampling ) / previousSampling )

            var positionSlicedArray = positionBufferAttribute.array.slice( 0, numberOfRestPoints * 3 )
            positionBufferAttribute.setArray( positionSlicedArray )
            positionBufferAttribute.needsUpdate = true

            var colorSlicedArray = colorBufferAttribute.array.slice( 0, numberOfRestPoints * 3 )
            colorBufferAttribute.setArray( colorSlicedArray )
            colorBufferAttribute.needsUpdate = true

        } )

    },

    createSamplingTable: function ( cloudIds ) {

        var samplingTable = new Map()
        var sampling      = undefined

        cloudIds.forEach( function ( cloudId ) {

            sampling = this._pointCloudsDataMap.get( cloudId ).sampling
            samplingTable.set( cloudId, sampling )

        }.bind( this ) )

        return samplingTable
    },

    requestDataBuffer: function ( url, dataToSend, cloud ) {

        var self = this

        var oReq = new XMLHttpRequest()
        oReq.open( 'POST', url, true )
        oReq.setRequestHeader( 'Content-Type', 'application/json' )
        oReq.responseType = 'arraybuffer'
        oReq.onload       = function ( oEvent ) {

            var arrayBuffer = oEvent.target.response
            if ( arrayBuffer.byteLength &lt;= 4 ) { return }

            var buffer          = new DataView( arrayBuffer )
            var numberOfBuffers = buffer.getUint32( 0 )
            if ( numberOfBuffers === 0 ) { return }

            console.log( 'numberOfBuffers to extract: ' + numberOfBuffers )

            const NUMBER_OF_BUFFER_VALUE_BYTES_LENGTH = 4 // UInt32
            var SIZES_OF_BUFFER_ARRAY_BYTES_LENGTH    = numberOfBuffers * 4 // UInt32
            var dataOffset                            = NUMBER_OF_BUFFER_VALUE_BYTES_LENGTH + SIZES_OF_BUFFER_ARRAY_BYTES_LENGTH

            var bufferLength = 0
            var byteArray    = undefined
            for ( var bufferIndex = 4 ; bufferIndex &lt;= SIZES_OF_BUFFER_ARRAY_BYTES_LENGTH ; bufferIndex += 4 ) {

                bufferLength = buffer.getUint32( bufferIndex )
                byteArray    = new Uint8Array( arrayBuffer, dataOffset, bufferLength )

                self.addPointsFromBuffer( byteArray, cloud )

                dataOffset += bufferLength

            }
        }

        oReq.send( JSON.stringify( dataToSend ) )

    },

    /**
     *
     * @param boundingBox
     * @param dataBuffer
     */
    addPointsFromBuffer: function ( dataBuffer ) {

        if ( !dataBuffer ) {
            console.error( 'No cube data to add on gpu !' )
            return
        }

        const CUBE_ID_BYTES_LENGTH = 24
        var cloudPointId                 = ''
        for ( var charIndex = 0 ; charIndex &lt; CUBE_ID_BYTES_LENGTH ; ++charIndex ) {
            cloudPointId += String.fromCharCode( dataBuffer[ charIndex ] )
        }

        const CUBE_POSITION_BYTES_LENGTH  = 3
        const HEADER_SIZE                 = CUBE_ID_BYTES_LENGTH + CUBE_POSITION_BYTES_LENGTH
        const POINT_POSITION_BYTES_LENGTH = 3
        const POINT_COLOR_BYTES_LENGTH    = 3
        const POINT_DATA_BYTES_LENGTH     = POINT_POSITION_BYTES_LENGTH + POINT_COLOR_BYTES_LENGTH
        var bufferSize                    = dataBuffer.length
        var numberOfPoint                 = (bufferSize - HEADER_SIZE) / POINT_DATA_BYTES_LENGTH

        var positions = new Float32Array( numberOfPoint * POINT_POSITION_BYTES_LENGTH )
        var colors    = new Float32Array( numberOfPoint * POINT_COLOR_BYTES_LENGTH )

        var pointCloudData         = this._pointCloudsDataMap.get( cloudPointId )
        var pointCloudCoordinates = pointCloudData.coordinates

        var bufferIndex     = 0
        var bufferDataIndex = HEADER_SIZE
        for ( var i = 0 ; i &lt; numberOfPoint ; i++ ) {

            // positions
            positions[ bufferIndex ]     = (dataBuffer[ bufferDataIndex ] / 1000) + pointCloudCoordinates.x - this._globalOffset.x
            positions[ bufferIndex + 1 ] = (dataBuffer[ bufferDataIndex + 1 ] / 1000) + pointCloudCoordinates.y - this._globalOffset.y
            positions[ bufferIndex + 2 ] = (dataBuffer[ bufferDataIndex + 2 ] / 1000) + pointCloudCoordinates.z - this._globalOffset.z

            // colors
            colors[ bufferIndex ]     = dataBuffer[ bufferDataIndex + 3 ] / 255
            colors[ bufferIndex + 1 ] = dataBuffer[ bufferDataIndex + 4 ] / 255
            colors[ bufferIndex + 2 ] = dataBuffer[ bufferDataIndex + 5 ] / 255

            bufferIndex += 3
            bufferDataIndex += 6

        }

        // If object already exist update it else create
        var pointCloud    = this._pointCloudGroup.getObjectByName( cloudPointId )
        if ( pointCloud ) {

            var positionBufferAttribute = pointCloud.geometry.getAttribute( 'position' )
            positionBufferAttribute.setArray( positions )
            positionBufferAttribute.needsUpdate = true

            var colorBufferAttribute = pointCloud.geometry.getAttribute( 'color' )
            colorBufferAttribute.setArray( colors )
            colorBufferAttribute.needsUpdate = true

        } else {

            var positionBufferAttribute = new BufferAttribute( positions, 3 )
            var colorBufferAttribute = new BufferAttribute( colors, 3 )

            var geometry = new BufferGeometry()
            geometry.addAttribute( 'position', positionBufferAttribute )
            geometry.addAttribute( 'color', colorBufferAttribute )

            var material        = new PointsMaterial( {
                size:         0.005,
                vertexColors: true
            } )

            var particleSystem  = new Points( geometry, material )
            particleSystem.name = cloudPointId
            particleSystem.rotation.x -= Math.PI / 2; //convert obj [y forward / z up] as [-z forward / y up]

            this._pointCloudGroup.add( particleSystem )

        }

    }

} )

export { TPointsManager }
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
